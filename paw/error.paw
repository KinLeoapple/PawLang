// main.paw — 多种可控编译错误示例

// 一个最小的 trait，后面会用到限定调用（Trait::method<...>(...)）
trait Eq<T> {
    fn eq(a: T, b: T) -> Bool;
}

// 故意只给 Int 提供 impl（让 Float 没有 impl 可用）
impl Eq<Int> {
    fn eq(a: Int, b: Int) -> Bool { a == b }
}

// —— 错误 1：返回类型为 Int，但 return 没带值
fn bad_return() -> Int {
    return;               // ERROR: function expects Int, but return without value
}

// —— 错误 2：if 分支类型不一致（then 是 Int，else 是 Double）
fn branch_mismatch() -> Int {
    let x: Int = 1;
    let y: Double = 3.14;
    let z = if x == 1 { 42 } else { y }; // ERROR: then `Int` vs else `Double`
    z
}

// —— 错误 3：while 条件不是 Bool
fn bad_while() -> Void {
    while 1 {             // ERROR: while condition expects Bool
        // ...
    }
}

// —— 错误 4：赋值类型不兼容（把 Double 赋给 Int）
fn bad_assign() -> Void {
    let n: Int = 1.5;     // ERROR: expect `Int`, got `Double`
}

// —— 错误 5：限定调用缺少显式类型实参
fn missing_generics_in_qualified_call() -> Bool {
    // 限定调用必须写成 Eq::eq<Int>(...), 少了 <Int> 会报错
    let b = Eq::eq(1, 2); // ERROR: qualified call needs explicit type args
    b
}

// —— 错误 6：有显式类型实参，但没有对应 impl
fn no_impl_for_type() -> Bool {
    // 我们没为 Float 提供 Eq 的 impl
    let b = Eq::eq<Float>(1.0, 2.0); // ERROR: missing `impl Eq<Float>`
    b
}

// —— 错误 7：调用未知函数
fn unknown_fun_call() -> Int {
    foo(123);             // ERROR: unknown function `foo`
    0
}

fn main() -> Int {
    bad_return();
    let _ = branch_mismatch();
    bad_while();
    bad_assign();
    let _ = missing_generics_in_qualified_call();
    let _ = no_impl_for_type();
    let _ = unknown_fun_call();

    // 再来一个 if 条件类型错误（非 Bool）
    if 3 {                // ERROR: if cond expects Bool
        1
    } else {
        0
    };

    0
}
