// paw/byte_test.paw
import "std::fmt";

// 直接绑定 runtime 的无符号 8 位打印函数
extern fn print_u8(x: Byte) -> Void;

// 复用 fmt 里已经声明的 rt_println()
extern fn rt_println() -> Void;

// 一个方便的 Byte 版 println
fn println_byte(x: Byte) -> Void {
    print_u8(x);
    rt_println();
}

/* 说明：
 * - 为了避免与有符号比较产生歧义，这里所有比较与算术都使用 < 128 的值。
 * - 溢出测试仅做“打印观测”，不做断言（语言当前未区分有/无符号比较语义）。
 */

fn test_byte_basics() -> Int {
    println("== Byte basics ==");
    let z: Byte = 0;
    let a: Byte = 5;
    let b: Byte = 10;
    println_byte(z);  // 0
    println_byte(a);  // 5
    println_byte(b);  // 10
    0
}

fn test_byte_arith() -> Int {
    println("== Byte arithmetic ==");
    let one: Byte = 1;
    let ten: Byte = 10;
    let a: Byte = 7;

    let s: Byte = a + one;  // 8
    let d: Byte = ten - a;  // 3
    let m: Byte = a * ten;  // 70
    let q: Byte = ten / a;  // 1（整除）

    println_byte(s);
    println_byte(d);
    println_byte(m);
    println_byte(q);
    0
}

// 观察环绕（按 8 位无符号模 256）
// 注意：只打印结果，不做比较断言
fn test_byte_wrap() -> Int {
    println("== Byte wrap (mod 256) ==");
    let x: Byte = 250;
    let y: Byte = 10;
    let w: Byte = x + y;    // 期望 4（若按 u8 环绕）
    println_byte(w);
    0
}

// 与 Int 混合：应提升到 Int（依赖你的类型提升规则）
fn test_mixed_promote() -> Int {
    println("== Byte + Int -> Int ==");
    let b: Byte = 7;
    // 打印 Int 结果（使用 std::fmt 的 println(Int) 重载）
    println(b + 100);       // 107（若按 Byte->Int 提升）
    0
}

// 用 Byte 作为循环计数器（仅做小范围计数，避开 127 边界）
fn test_for_with_byte_counter() -> Int {
    println("== for with Byte counter ==");
    let sum: Int = 0;
    for (let i: Byte = 0; i < 10; i = i + 1) {
        // 把 Byte 累加到 Int（依赖 Byte->Int 提升），验证参与数值运算
        sum = sum + i;
    }
    println(sum); // 0+1+...+9 = 45
    0
}

fn main() -> Int {
    test_byte_basics();
    test_byte_arith();
    test_byte_wrap();
    test_mixed_promote();
    test_for_with_byte_counter();
    0
}
