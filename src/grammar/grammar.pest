//////////////////////////////
// PawLang grammar.pest
// - 支持 trait / impl / where
// - 安全的泛型调用后缀：ty_args? "(" arg_list? ")"
// - 类型：内建 + 类型变量 + 类型应用 + 零参类型名
// - 新增：显式类型转换 as（低于算术优先级，右侧可链式 as）
//////////////////////////////

// ===== 基础/空白与注释 =====
UPPER         = _{ 'A'..'Z' }
IDENT_NEXT    = _{ ASCII_ALPHANUMERIC | "_" }

WHITESPACE    = _{ ( " " | "\t" | "\r" | NEWLINE | COMMENT )+ }
COMMENT       = _{ LINE_COMMENT | BLOCK_COMMENT }
LINE_COMMENT  = _{ "//" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }
BLOCK_COMMENT = _{ "/*" ~ (BLOCK_COMMENT | (!"*/" ~ ANY))* ~ "*/" }

// ===== 程序结构 =====
program = { SOI ~ item* ~ EOI }

// 顶层项：函数 / 外部函数 / 变量声明 / 导入 / trait / impl
item = { extern_fun | fun_decl | let_decl | import_decl | trait_decl | impl_decl }

// ===== 函数 / 外部函数 / 导入 / 参数 =====
fun_decl    = { KW_FN ~ ident ~ ty_params? ~ "(" ~ param_list? ~ ")" ~ "->" ~ ty ~ where_clause? ~ block }
extern_fun  = { KW_EXTERN ~ KW_FN ~ ident ~ "(" ~ param_list? ~ ")" ~ "->" ~ ty ~ ";" }
import_decl = { KW_IMPORT ~ string_lit ~ ";" }

param_list = { param ~ ("," ~ param)* }
param      = { ident ~ ":" ~ ty }

// 顶层变量声明
let_decl = { ( KW_LET | KW_CONST ) ~ ident ~ ":" ~ ty ~ "=" ~ expr ~ ";" }

// ===== 类型系统 =====
// 类型变量（T/U/... 大写开头）
ty_var = @{ UPPER ~ (ASCII_ALPHANUMERIC | "_")* }

// 类型应用：如 Vec<Int>, Map<String, Int>
ty_app   = { (qident | ident) ~ "<" ~ ty ~ ("," ~ ty)* ~ ">" }

// 内建原子类型
ty_prim = { KW_Int | KW_Long | KW_Byte | KW_Bool | KW_String | KW_Double | KW_Float | KW_Char | KW_Void }

// 顶层类型选择：应用类型 / 内建 / 类型变量 / 零参类型名
ty = { ty_app | ty_prim | ty_var | ident }

// 函数声明里的类型形参（<T, U>）
ty_ident  = @{ UPPER ~ (ASCII_ALPHANUMERIC | "_")* }
ty_params = { "<" ~ ty_ident ~ ("," ~ ty_ident)* ~ ">" }

// 调用处/impl 处的类型实参（<Int, String, Vec<T>>）
ty_args   = { "<" ~ ty ~ ("," ~ ty)* ~ ">" }

// ===== where 子句（约束） =====
// 例如：where T: Eq + Show, U: Ord, Pair<Int,Long>: Foo<Int>
where_clause = { KW_WHERE ~ where_item ~ ("," ~ where_item)* }
where_item   = { where_pred | bound }
where_pred   = { ty ~ ":" ~ bound ~ ("+" ~ bound)* }
// 约束名允许将来带实参，如 Iterator<Item=T>（此处先留钩子）
bound        = { (qident | ident) ~ ("<" ~ ty ~ ("," ~ ty)* ~ ">")? }

// ===== 语句/表达式与块 =====
block      = { "{" ~ stmt* ~ tail_expr? ~ "}" }

stmt       = {
    let_decl
  | assign_stmt
  | while_stmt
  | for_stmt
  | if_stmt
  | break_stmt
  | continue_stmt
  | return_stmt
  | expr_stmt
}

assign_stmt = { ident ~ "=" ~ expr ~ ";" }

while_stmt = { KW_WHILE ~ "(" ~ expr ~ ")" ~ block }

for_stmt = { KW_FOR ~ "(" ~ for_init? ~ ";" ~ expr? ~ ";" ~ for_step? ~ ")" ~ block }
for_init = {
      (KW_LET | KW_CONST) ~ ident ~ ":" ~ ty ~ "=" ~ expr
    | ident ~ "=" ~ expr
    | expr
}
for_step = { ident ~ "=" ~ expr | expr }

if_stmt = { KW_IF ~ "(" ~ expr ~ ")" ~ block ~ (KW_ELSE ~ block)? }

break_stmt    = { KW_BREAK ~ ";" }
continue_stmt = { KW_CONTINUE ~ ";" }

return_stmt = { KW_RETURN ~ expr? ~ ";" }
expr_stmt   = { expr ~ ";" }
tail_expr   = { expr }

// ===== 表达式优先级 =====
// 顶层
expr        = { logic_or }
logic_or    = { logic_and ~ (OP_OR  ~ logic_and)* }
logic_and   = { equality  ~ (OP_AND ~ equality )* }
equality    = { compare   ~ ((OP_EQ | OP_NE) ~ compare)* }
compare     = { add       ~ ((OP_LE | OP_GE | OP_LT | OP_GT) ~ add)* }

// 将显式类型转换 cast 插入到加法层与乘法层之间：
// 使 `1 + 2 as Long` 解析为 `1 + (2 as Long)`（加法比 as 绑定更紧）
add         = { cast_term ~ ((OP_ADD | OP_SUB) ~ cast_term)* }
cast_term   = { cast | mult }
// 链式 as：x as Int as Long
cast        = { mult ~ (KW_AS ~ ty)+ }

mult        = { unary     ~ ((OP_MUL | OP_DIV) ~ unary)* }
unary       = { (OP_NOT | OP_SUB) ~ unary | postfix }

// 可调用名：单段 ident 或 多段 qident（Trait::method）
qident   = @{ ident ~ ("::" ~ ident)+ }
name_ref = { qident | ident }

// 后缀：仅支持“安全泛型调用后缀”（ty_args? + "(" args? ")"）
postfix       = { name_ref ~ call_suffix+ | primary_head ~ call_suffix* }
primary_head  = { float_lit | double_lit | long_lit | int_lit | bool_lit | string_lit | char_lit
                | if_expr | match_expr | name_ref | group | block
                }
// 为了兼容旧 parser：允许用 Rule::primary 来匹配
primary       = { primary_head }

call_suffix = { ty_args? ~ "(" ~ arg_list? ~ ")" }
arg_list    = { expr ~ ("," ~ expr)* }

// ===== 原子表达式 =====
group   = { "(" ~ expr ~ ")" }

// if 作为表达式（有 else 才有值）
if_expr = { KW_IF ~ "(" ~ expr ~ ")" ~ block ~ KW_ELSE ~ block }

// match 表达式
match_expr  = { KW_MATCH ~ "(" ~ expr ~ ")" ~ "{" ~ match_arms? ~ "}" }
match_arms  = {
    (match_arm ~ ("," ~ match_arm)*) ~ ("," ~ match_default)? ~ (",")?
  | match_default ~ (",")?
}
match_arm     = { pattern ~ "=>" ~ block }
match_default = { "_" ~ "=>" ~ block }

// 模式：整数/长整/布尔/字符/通配
pattern = { long_lit | int_lit | bool_lit | char_lit | "_" }

// ===== 字面量 =====
int_lit    = @{ "-"? ~ ASCII_DIGIT+ }
long_lit   = @{ "-"? ~ ASCII_DIGIT+ ~ ("L" | "l") }
bool_lit   = { KW_true | KW_false }
float_lit  = @{
  "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~
  (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)? ~
  ("f" | "F")
}
double_lit = @{
  "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~
  (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}

char_lit = @{
  "'" ~ (
      ( !("'" | "\\") ~ ANY )
    | "\\" ~ ( "'" | "\\" | "n" | "r" | "t" | "0" | ( "u{" ~ ASCII_HEX_DIGIT{1,6} ~ "}" ) )
  ) ~ "'"
}

string_lit = @{
  "\"" ~ (
      "\\\"" | "\\\\" | "\\n" | "\\r" | "\\t" | "\\0"
    | ( "\\u{" ~ ASCII_HEX_DIGIT{1,6} ~ "}" )
    | ( !"\"" ~ ANY )
  )* ~ "\""
}

// ===== trait / impl =====
trait_decl = { KW_TRAIT ~ ident ~ ty_params? ~ "{" ~ trait_item* ~ "}" }
trait_item = { KW_FN ~ ident ~ "(" ~ param_list? ~ ")" ~ "->" ~ ty ~ ";" }

// 允许 impl Foo<A, B> {...} 或 impl Foo {...}（让 typecheck 去判是否缺实参）
impl_decl  = { KW_IMPL  ~ ident ~ ty_args?  ~ "{" ~ impl_item*  ~ "}" }
impl_item  = { KW_FN ~ ident ~ "(" ~ param_list? ~ ")" ~ "->" ~ ty ~ block }

// ===== 标识符 / 关键字 / 运算符 =====
ident = @{ !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

keyword = {
  (
      KW_FN | KW_EXTERN | KW_IMPORT | KW_LET | KW_CONST
    | KW_IF | KW_ELSE | KW_WHILE | KW_FOR | KW_BREAK | KW_CONTINUE | KW_MATCH
    | KW_RETURN | KW_TRAIT | KW_IMPL | KW_WHERE | KW_AS
    | KW_Int | KW_Long | KW_Byte | KW_Bool | KW_String | KW_Double | KW_Float | KW_Char | KW_Void
    | KW_true | KW_false
  ) ~ !IDENT_NEXT
}

// 关键字
KW_FN      = @{ "fn"      ~ !IDENT_NEXT }
KW_EXTERN  = @{ "extern"  ~ !IDENT_NEXT }
KW_IMPORT  = @{ "import"  ~ !IDENT_NEXT }
KW_LET     = @{ "let"     ~ !IDENT_NEXT }
KW_CONST   = @{ "const"   ~ !IDENT_NEXT }
KW_IF      = @{ "if"      ~ !IDENT_NEXT }
KW_ELSE    = @{ "else"    ~ !IDENT_NEXT }
KW_WHILE   = @{ "while"   ~ !IDENT_NEXT }
KW_FOR     = @{ "for"     ~ !IDENT_NEXT }
KW_BREAK   = @{ "break"   ~ !IDENT_NEXT }
KW_CONTINUE= @{ "continue"~ !IDENT_NEXT }
KW_MATCH   = @{ "match"   ~ !IDENT_NEXT }
KW_RETURN  = @{ "return"  ~ !IDENT_NEXT }

KW_TRAIT   = @{ "trait"   ~ !IDENT_NEXT }
KW_IMPL    = @{ "impl"    ~ !IDENT_NEXT }
KW_WHERE   = @{ "where"   ~ !IDENT_NEXT }
KW_AS      = @{ "as"      ~ !IDENT_NEXT }

KW_Int     = @{ "Int"    ~ !IDENT_NEXT }
KW_Long    = @{ "Long"   ~ !IDENT_NEXT }    // i64
KW_Byte    = @{ "Byte"   ~ !IDENT_NEXT }
KW_Bool    = @{ "Bool"   ~ !IDENT_NEXT }
KW_String  = @{ "String" ~ !IDENT_NEXT }
KW_Double  = @{ "Double" ~ !IDENT_NEXT }    // f64
KW_Float   = @{ "Float"  ~ !IDENT_NEXT }    // f32
KW_Char    = @{ "Char"   ~ !IDENT_NEXT }    // u32（ABI 用 i32）
KW_Void    = @{ "Void"   ~ !IDENT_NEXT }
KW_true    = @{ "true"   ~ !IDENT_NEXT }
KW_false   = @{ "false"  ~ !IDENT_NEXT }

// 运算符（注意 <= / >= 在 < / > 之前）
OP_OR  = { "||" }
OP_AND = { "&&" }
OP_EQ  = { "==" }
OP_NE  = { "!=" }
OP_LE  = { "<=" }
OP_GE  = { ">=" }
OP_LT  = { "<"  }
OP_GT  = { ">"  }
OP_ADD = { "+"  }
OP_SUB = { "-"  }
OP_MUL = { "*"  }
OP_DIV = { "/"  }
OP_NOT = { "!"  }
